# EMBARGO: LLM-Optimized Codebase Dependency Graph

**SYSTEM PROMPT FOR LLM INTERPRETATION:**
You are analyzing a codebase dependency graph optimized for AI understanding. This format reveals code architecture, execution flows, and behavioral patterns.

## INTERPRETATION KEY

### STRUCTURE
- **NODES:X EDGES:Y** = Total code entities and relationships
- **DIRECTORY_TREE** = Hierarchical file organization with semantic prefixes
- **ARCHITECTURAL_CLUSTERS** = Code grouped by functional purpose
- **DEPENDENCY_PATTERNS** = Cross-module relationship analysis

### BEHAVIORAL NOTATION
- **filename.rs→[...]** = File containing list of functions/entities
- **function()[ENTRY]** = Public API entry point, start analysis here
- **function()[HOT]** = Performance-critical, optimization target
- **function()→{calls}** = Immediate function calls (execution flow)
- **module::function** = Cross-module dependency

### ANALYSIS GUIDANCE
1. **Entry Points**: Start with [ENTRY] functions to understand public APIs
2. **Execution Flow**: Follow →{calls} to trace code execution paths
3. **Hot Paths**: Focus [HOT] functions for performance analysis
4. **Architecture**: Use clusters to understand system organization
5. **Dependencies**: Cross-cluster flows show coupling patterns

### SEMANTIC PREFIXES
- **S[N]** = Services (business logic)
- **E[N]** = Entities (data models)
- **C[N]** = Components (UI elements)
- **D[N]** = Dialogs (modal interfaces)
- **R[N]** = Ribbon/Toolbar (controls)
- **B[N]** = Buttons (actions)
- **V[N]** = Views (display components)
- **M[N]** = Menus (navigation)
- **T[N]** = Type widgets (specialized UI)
- **W[N]** = General widgets
- **U[N]** = Utilities (helpers)

### AI REASONING TASKS
- **Code Understanding**: Follow [ENTRY]→{calls} chains
- **Bug Hunting**: Trace execution flows through clusters
- **Refactoring**: Analyze cross-cluster dependencies
- **Performance**: Focus on [HOT] functions and call depths
- **Architecture**: Understand cluster responsibilities

---

# CODE_GRAPH
NODES:410 EDGES:203

## DIRECTORY_TREE
ROOT: torchtitan/experiments/fl/
├─ configs/ → U[2]
├─ dataloader/ → U[2]
├─ models/ → E[12]
│  ├─ llama3_mup/ → E[9]
│  │  ├─ infra/ → E[2]
│  │  ├─ model/ → E[4]
│  │  ├─ tests/ → E[1]
│  │  └─ train_configs/ → E[1]
│  ├─ mosaic_llama3/ → E[1]
│  └─ mosaic_llama3_mup/ → E[1]
└─ optimizers/ → U[8]

## ARCHITECTURAL_CLUSTERS

### DATA_MODELS
NODES:100 CALL_DEPTH:2

__init__.py→[build_mosaic_mup_optimizers((model_parts: list[nn.Module],optimizer_config: OptimizerConfig | dict[str,Any],parallel_dims: ParallelDims,ft_manager: FTManager | None = None,))[HOT]→{optimizer_builder::build_mosaic_optimizers},_get_llama3_mup_spec(void),get_train_spec(void),build_mup_optimizers((model_parts: list[nn.Module],optimizer_config: OptimizerConfig,parallel_dims: ParallelDims,ft_manager: FTManager | None = None,))[HOT],get_train_spec(void),get_train_spec(void)] mup_args.py→[] mup_model.py→[_precompute_freqs_cis((self))[HOT]→{_precompute_freqs_cis},init_weights((self,init_std: float)),init_weights((self,init_std: float)),__init__((self,layer_id: int,model_args: TransformerModelArgs # noqa: ARG002))[CTOR,DUNDER],forward((self,x: torch.Tensor,freqs_cis: torch.Tensor,)),init_weights((self)),__init__((self,model_args: TransformerModelArgs))[CTOR,DUNDER],init_weights((self,buffer_device: torch.device | None = None)),get_optimizer_param_groups((self,optimizer_config: dict[str,Any])),forward((self,tokens: torch.Tensor,input_batch: torch.Tensor | None = None,# noqa: ARG002))] parallelize.py→[parallelize_llama_mup((model: nn.Module,parallel_dims: ParallelDims,job_config: JobConfig,))] state_dict_adapter.py→[__init__((self,model_args: TransformerModelArgs,hf_assets_path: str | None,))[CTOR,DUNDER]] test_mup_model.py→[setUp((self)),test_model_initialization((self))[TEST],test_forward_pass((self))[TEST],test_weight_initialization((self))[TEST]] 
### UTILITY_LAYER
NODES:310 CALL_DEPTH:6

__init__.py→[] _decoupled_decay.py→[_compute_decay_factor((lr: float | Tensor,initial_lr: float | Tensor | None))[HOT]] adopt.py→[_multi_tensor_adopt((# noqa: C901,PLR0912,PLR0913,PLR0915 params: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],state_steps: list[Tensor],grad_scale: Tensor | None,found_inf: Tensor | None,*,initial_lr: float | None,has_complex: bool,beta1: float,beta2: float,lr: float | Tensor,clip_lambda: Callable[[Number | Tensor | Any],float] | None,weight_decay: float,decouple: bool,eps: float,maximize: bool,capturable: bool,differentiable: bool,))→{_decoupled_decay::_compute_decay_factor,_decoupled_decay::_compute_decay_factor},report_per_parameter_metrics((self,param: torch.Tensor,name: str,optimizer_metrics: dict[str,torch.Tensor],))→{_decoupled_decay::_compute_decay_factor},_single_tensor_adopt((# noqa: PLR0913 params: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],state_steps: list[Tensor],grad_scale: Tensor | None,found_inf: Tensor | None,*,initial_lr: float | None,decouple: bool,clip_lambda: Callable[[Number | Tensor | Any],float] | None,beta1: float,beta2: float,lr: float | Tensor,weight_decay: float,eps: float,maximize: bool,capturable: bool,differentiable: bool,has_complex: bool,# noqa: ARG001))→{_decoupled_decay::_compute_decay_factor},_default_clip_lambda((step: Number | Tensor)),__init__((# noqa: C901,PLR0913 self,params: ParamsT,lr: float | Tensor = 1e-3,betas: tuple[float,float] = (0.9,0.9999),eps: float = 1e-6,clip_lambda: (Callable[[Number | Tensor | Any],float] | None) = _default_clip_lambda,weight_decay: float = 0.0,*,decouple: bool = False,foreach: bool | None = None,maximize: bool = False,capturable: bool = False,differentiable: bool = False,fused: bool | None = None,))[CTOR,DUNDER],__setstate__((self,state: dict))[DUNDER],_init_group((# noqa: PLR0913 self,group: dict,params_with_grad: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],state_steps: list[Tensor],)),_fused_adopt((# noqa: PLR0913 params: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],state_steps: list[Tensor],grad_scale: Tensor | None,found_inf: Tensor | None,*,initial_lr: float | None,has_complex: bool,beta1: float,beta2: float,lr: float | Tensor,clip_lambda: Callable[[int],float] | None,weight_decay: float,decouple: bool,eps: float,maximize: bool,capturable: bool,differentiable: bool,))] aggmo_adamw.py→[report_per_parameter_metrics((# noqa: D102 self,param: torch.Tensor,name: str,optimizer_metrics: dict[str,torch.Tensor],))→{_decoupled_decay::_compute_decay_factor,aggmo_adopt::_sum_weights,aggmo_adopt::_build_moment_specs},_validate_vs_tuple((self,vs: Sequence[float]))→{aggmo_adopt::_sum_weights,aggmo_adopt::_build_moment_specs},_single_tensor_aggmo_qhadamw((# noqa: C901,PLR0913,PLR0912 params: list[Tensor],grads: list[Tensor],moment_buffers: list[list[Tensor]],exp_avg_sqs: list[Tensor],max_exp_avg_sqs: list[Tensor] | None,state_steps: list[Tensor],grad_scale: Tensor | None,found_inf: Tensor | None,*,initial_lr: float | Tensor | None,decouple: bool,amsgrad: bool,beta1s: Sequence[float],beta2: float,vs: Sequence[float],lr: float | Tensor,weight_decay: float,eps: float,maximize: bool,capturable: bool,differentiable: bool,has_complex: bool,# noqa: ARG001 grad_coeff: float,))→{_decoupled_decay::_compute_decay_factor,aggmo_adopt::_build_moment_specs},_validate_betas_tuple((self,betas: Sequence[float],vs: Sequence[float]))→{aggmo_adopt::_build_moment_specs},_setup_metric_functions((self,vs: Sequence[float]))→{aggmo_adopt::_build_moment_specs},_prepare_param_state((# noqa: C901 self,group: dict[str,Any],param: Tensor,moment_specs: Sequence[tuple[float,str]],))→
{aggmo_adopt::_is_moment_key},__init__((# noqa: PLR0913 self,params: ParamsT,lr: float | Tensor = 1e-3,betas: tuple[float,...] = (0.9,0.95),vs: tuple[float,...] = (0.7,),eps: float = 1e-8,weight_decay: float = 1e-5,*,amsgrad: bool = False,decouple: bool = True,foreach: bool | None = None,maximize: bool = False,capturable: bool = False,differentiable: bool = False,fused: bool | None = None,))[CTOR,DUNDER],_validate_param_groups((self))] aggmo_adopt.py→[report_per_parameter_metrics((# noqa: D102 self,param: torch.Tensor,name: str,optimizer_metrics: dict[str,torch.Tensor],))→{_sum_weights,_build_moment_specs,_decoupled_decay::_compute_decay_factor},_validate_vs_tuple((self,vs: Sequence[float]))→{_sum_weights,_build_moment_specs},_single_tensor_aggmo_qhadopt((# noqa: C901,PLR0913 params: list[Tensor],grads: list[Tensor],moment_buffers: list[list[Tensor]],exp_avg_sqs: list[Tensor],state_steps: list[Tensor],grad_scale: Tensor | None,found_inf: Tensor | None,*,initial_lr: float | Tensor | None,decouple: bool,clip_lambda: Callable[[Number | Tensor | Any],float] | None,beta1s: Sequence[float],beta2: float,vs: Sequence[float],lr: float | Tensor,weight_decay: float,eps: float,maximize: bool,capturable: bool,differentiable: bool,has_complex: bool,# noqa: ARG001 grad_coeff: float,))→{_build_moment_specs,_decoupled_decay::_compute_decay_factor},_validate_betas_tuple((self,betas: Sequence[float],vs: Sequence[float]))→{_build_moment_specs},_setup_metric_functions((self,vs: Sequence[float]))→{_build_moment_specs},_prepare_param_state((self,group: dict[str,Any],param: Tensor,moment_specs: Sequence[tuple[float,str]],))→{_is_moment_key},_build_moment_specs((vs: Sequence[float]))[HOT],_is_moment_key((key: str)),_sum_weights((moment_specs: Iterable[tuple[float,str]])),__init__((# noqa: PLR0913 self,params: ParamsT,lr: float | Tensor = 1e-3,betas: tuple[float,...] = (0.999,0.9999),vs: tuple[float,...] = (0.9,),eps: float = 1e-6,clip_lambda: (Callable[[Number | Tensor | Any],float] | None) = _default_clip_lambda,weight_decay: float = 0.0,*,decouple: bool = False,foreach: bool | None = None,maximize: bool = False,capturable: bool = False,differentiable: bool = False,fused: bool | None = None,))[CTOR,DUNDER],_validate_param_groups((self))] components.py→[build_metrics_processor((job_config: JobConfig,parallel_dims: ParallelDims,model_args: BaseModelArgs | None = None,# noqa: ARG001 tag: str | None = None,))[HOT]] config.py→[] dataloader.py→[_extract_streams((dataset_cfg: dict[str,Any]))→{_join_local_path,_join_remote_path,_collect_group_stream_entries,_normalize_sampling_groups,_flatten_stream_configs,desloc::tick},_join_remote_path((root: str | None,path: str | None))→{_is_uri,_is_uri},_build_mosaic_dataloader((*,job_config: MosaicJobConfig,tokenizer: BaseTokenizer,dp_world_size: int,dp_rank: int,split: str,default_drop_last: bool,))[HOT]→{_extract_streams,_select_dataset_config},_normalize_sampling_groups((config: Any))→{desloc::tick},_collect_group_stream_entries((group: Mapping[str,Any]))→{_flatten_stream_configs},_select_dataset_config((dataset_cfg: Mapping[str,Any] | None,split: str))→{desloc::tick},build_mosaic_dataloader((*,dp_world_size: int,dp_rank: int,tokenizer: BaseTokenizer,job_config: MosaicJobConfig,))[HOT]→{_build_mosaic_dataloader},build_mosaic_validation_dataloader((*,dp_world_size: int,dp_rank: int,tokenizer: BaseTokenizer,job_config: MosaicJobConfig,infinite: bool = False,# noqa: ARG001 - kept for compatibility))[HOT]→
{_build_mosaic_dataloader},_is_uri((path: str | None)),_join_local_path((root: str | None,path: str | None)),_flatten_stream_configs((streams_cfg: Any)),__init__((self,*args: Any,**kwargs: Any))[CTOR,DUNDER],__getitem__((self,idx: int))[DUNDER],state_dict((self,num_samples: int | None = None,from_beginning: bool = True)),load_state_dict((self,obj: dict[str,Any])),__init__((self,dataset: StatefulStreamingTextDataset,dp_rank: int,dp_world_size: int,batch_size: int,collate_fn: Callable | None = None,num_workers: int = 0,prefetch_factor: int | None = 2,pin_memory: bool = True,persistent_workers: bool = True,drop_last: bool = True,))[CTOR,DUNDER],state_dict((self)),load_state_dict((self,state_dict: dict[str,Any])),titan_collate_fn((batch: list[Any]))] decoupled_adamw.py→[report_per_parameter_metrics((self,param: torch.Tensor,name: str,optimizer_metrics: dict[str,torch.Tensor],))→{_decoupled_decay::_compute_decay_factor},__init__((# noqa: PLR0913 self,params: Iterable[torch.Tensor] | Iterable[dict],lr: float = 1e-3,betas: tuple[float,float] = (0.9,0.95),eps: float = 1e-8,weight_decay: float = 1e-5,*,amsgrad: bool = False,decouple: bool = True,foreach: bool | None = None,maximize: bool = False,capturable: bool = False,differentiable: bool = False,fused: bool | None = None,))[CTOR,DUNDER]] desloc.py→[_init_backup_storage((self))→{_extract_local_tensor},save_state((self))→{_extract_local_tensor},restore_state((self))→{_copy_into_tensor},prepare_sync((self))→{_extract_local_tensor},perform_sync((self))→{_copy_into_tensor},__init__((self,*,manager: Any,model: nn.Module,optimizer: Optimizer,param_sync_every: int,optimizer_sync_every: int | list[int] | dict[str,int] | None,backup_device: torch.device | None,pin_memory: bool,name_prefix: str,quorum_timeout_seconds: int,))[CTOR,DUNDER]→{train::main},_lazy_init_optimizer_fragments((self))→{test_mup_model::setUp},_extract_local_tensor((tensor: torch.Tensor)),_copy_into_tensor((param: torch.Tensor,value: torch.Tensor)),__init__((self,sync_every: int))[CTOR,DUNDER],tick((self)),reset((self)),prepare_sync((self)),perform_sync((self)),save_state((self)),restore_state((self)),__init__((self,manager: Any,model: nn.Module,sync_every: int,backup_device: torch.device | None,pin_memory: bool,name_prefix: str,))[CTOR,DUNDER],register_state_dict_fn((self)),__init__((self,manager: Any,model: nn.Module,optimizer: Optimizer,state_key: str,sync_every: int,backup_device: torch.device | None,name_prefix: str,))[CTOR,DUNDER],_init_backup_storage((self)),save_state((self)),restore_state((self)),prepare_sync((self)),perform_sync((self)),register_state_dict_fn((self)),close((self)),_resolve_optimizer_sync_intervals((self,state_keys: Iterable[str]))[HOT],_step_post_hook((self,_optimizer: Optimizer,_args: tuple[Any,...],_kwargs: dict[str,Any],)),_sync((self,fragments: list[_BaseFragment])),_prepare_sync((self,fragments: list[_BaseFragment])),_perform_sync((self,fragments: list[_BaseFragment])),__init__((self,model_parts: list[nn.Module],optimizer_cls: type[Optimizer],optimizer_kwargs: dict[str,Any],ft_manager: Any,desloc_config: DesLocConfig,*,use_ft_optimizer: bool = True,param_groups: list[dict[str,Any]] | None = None,))[CTOR,DUNDER],close_desloc((self))] ft_override.py→[enable_desloc_only_ft((job_config))] metrics.py→[_add_metrics((# noqa: C901,PLR0912,PLR0915 self,suffix: str,value: torch.Tensor))→{compute_kurtosis,compute_skewness},batch_end((# noqa: C901,PLR0912,PLR0915 self,step: int,model: torch.nn.Module,optimizers: OptimizersContainer,logger: Any,mesh: DeviceMesh | None = None,))→{train::main,train::main},__init__((self,*,interval: int = 25,ignore_module_types: Sequence[str] | None = None,gradient_accumulation_steps: int = 1,enabled_metrics: set[str] | None = None,))[CTOR,DUNDER]→{train::main},_prepare_local_metrics((self))→
{train::main},compute_skewness((value: torch.Tensor))[HOT],compute_kurtosis((value: torch.Tensor))[HOT],_is_metric_enabled((self,metric_key: str)),should_log_step((self,step: int)),register((self,model: torch.nn.Module)),_register_forward_hook((self,module: torch.nn.Module)),_forward_pre_hook((self,module: torch.nn.Module,args: tuple[Any,...],kwargs: dict[str,Any],)),_forward_hook((self,module: torch.nn.Module,inputs: tuple[Any,...],output: Any,)),_recursively_add_metrics((self,suffix: str,values: Any)),finalize((self,step: int,logger: Any,mesh: DeviceMesh | None,)),_reduce_metrics((# noqa: C901,PLR0912 self,metrics: dict[str,float | list[float]],mesh: DeviceMesh | None)),_reset_metrics((self)),__init__((self,interval: int = 10,*,only_global: bool = True,log_optimizer_metrics: bool = True,))[CTOR,DUNDER],_reduce_metrics_across_ranks((self,optimizer_metrics: dict[str,torch.Tensor],mesh: DeviceMesh)),__init__((self,*args: Any,**kwargs: Any))[CTOR,DUNDER],should_log((self,step: int)),log((self,step: int,global_avg_loss: float,global_max_loss: float,grad_norm: float,extra_metrics: dict[str,Any] | None = None,))] optimizer_builder.py→[build_mosaic_optimizers((# noqa: C901,PLR0912 model_parts: list[torch.nn.Module],optimizer_config: MosaicOptimizerConfig | dict[str,Any],parallel_dims: ParallelDims,ft_manager: FTManager | None = None,param_groups: list[dict[str,Any]] | None = None,))[HOT]] optimizers.py→[] qhadamw.py→[report_per_parameter_metrics((self,param: torch.Tensor,name: str,optimizer_metrics: dict[str,torch.Tensor],))→{_decoupled_decay::_compute_decay_factor},_single_tensor_qhadamw((# noqa: PLR0913 params: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],max_exp_avg_sqs: list[Tensor],state_steps: list[Tensor],grad_scale: Tensor | None,found_inf: Tensor | None,*,initial_lr: float | None,decouple: bool,amsgrad: bool,beta1: float,beta2: float,v1: float,lr: float | Tensor,weight_decay: float,eps: float,maximize: bool,capturable: bool,differentiable: bool,has_complex: bool,# noqa: ARG001))→{_decoupled_decay::_compute_decay_factor},_multi_tensor_qhadamw((# noqa: C901,PLR0913,PLR0912,PLR0915 params: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],max_exp_avg_sqs: list[Tensor],state_steps: list[Tensor],grad_scale: Tensor | None,found_inf: Tensor | None,*,initial_lr: float | None,has_complex: bool,amsgrad: bool,beta1: float,beta2: float,v1: float,lr: float | Tensor,weight_decay: float,decouple: bool,eps: float,maximize: bool,capturable: bool,differentiable: bool,))→{_decoupled_decay::_compute_decay_factor},__init__((# noqa: PLR0913,PLR0912,C901 self,params: ParamsT,lr: float | Tensor = 1e-3,betas: tuple[float,float] = (0.9,0.95),vs: tuple[float,...] = (0.7,),eps: float = 1e-8,weight_decay: float = 1e-5,*,amsgrad: bool = False,decouple: bool = True,foreach: bool | None = None,maximize: bool = False,capturable: bool = False,differentiable: bool = False,fused: bool | None = None,))[CTOR,DUNDER],__setstate__((self,state: dict))[DUNDER],_init_group((# noqa: PLR0913 self,group: dict,params_with_grad: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],max_exp_avg_sqs: list[Tensor],state_steps: list[Tensor],)),_fused_qhadamw((*args: Any,**kwargs: Any,))] qhadopt.py→[_multi_tensor_qhadopt((# noqa: C901,PLR0912,PLR0913,PLR0915 params: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],state_steps: list[Tensor],grad_scale: Tensor | None,found_inf: Tensor | None,*,initial_lr: float | None,has_complex: bool,beta1: float,beta2: float,v1: float,lr: float | Tensor,clip_lambda: Callable[[Number | Tensor | Any],float] | None,weight_decay: float,decouple: bool,eps: float,maximize: bool,capturable: bool,differentiable: bool,))→
{_decoupled_decay::_compute_decay_factor,_decoupled_decay::_compute_decay_factor},report_per_parameter_metrics((self,param: torch.Tensor,name: str,optimizer_metrics: dict[str,torch.Tensor],))→{_decoupled_decay::_compute_decay_factor},_single_tensor_qhadopt((# noqa: PLR0913 params: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],state_steps: list[Tensor],grad_scale: Tensor | None,found_inf: Tensor | None,*,initial_lr: float | None,decouple: bool,clip_lambda: Callable[[Number | Tensor | Any],float] | None,beta1: float,beta2: float,v1: float,lr: float | Tensor,weight_decay: float,eps: float,maximize: bool,capturable: bool,differentiable: bool,has_complex: bool,# noqa: ARG001))→{_decoupled_decay::_compute_decay_factor},_default_clip_lambda((step: Number | Tensor)),__init__((# noqa: C901,PLR0913,PLR0912 self,params: ParamsT,lr: float | Tensor = 1e-3,betas: tuple[float,float] = (0.999,0.9999),vs: tuple[float,...] = (0.9,),eps: float = 1e-6,clip_lambda: (Callable[[Number | Tensor | Any],float] | None) = _default_clip_lambda,weight_decay: float = 0.0,*,decouple: bool = False,foreach: bool | None = None,maximize: bool = False,capturable: bool = False,differentiable: bool = False,fused: bool | None = None,))[CTOR,DUNDER],__setstate__((self,state: dict))[DUNDER],_init_group((# noqa: PLR0913 self,group: dict,params_with_grad: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],state_steps: list[Tensor],)),_fused_qhadopt((# noqa: PLR0913 params: list[Tensor],grads: list[Tensor],exp_avgs: list[Tensor],exp_avg_sqs: list[Tensor],state_steps: list[Tensor],grad_scale: Tensor | None,found_inf: Tensor | None,*,initial_lr: float | None,has_complex: bool,beta1: float,beta2: float,v1: float,lr: float | Tensor,clip_lambda: Callable[[int],float] | None,weight_decay: float,decouple: bool,eps: float,maximize: bool,capturable: bool,differentiable: bool,))] s3_checkpoint.py→[__init__((self,checkpointer: CheckpointManager,config: S3CheckpointingConfig,job_config: MosaicJobConfig,))[CTOR,DUNDER]→{create_remote_up_down,test_mup_model::setUp,test_mup_model::setUp,test_mup_model::setUp},_download_step((self,step: int,remote_path: str))→{download_file_from_s3,download_file_from_s3,train::main},_upload_step((self,step: int,directory: Path))→{upload_file_to_s3},_write_latest_marker((self,step: int))→{upload_file_to_s3},_read_remote_latest_step((self,remote_root: str | None = None))→{download_file_from_s3},download_file_from_s3((remote_up_down: RemoteUploaderDownloader,remote_file_name: str,local_file_name: Path | str,)),upload_file_to_s3((remote_up_down: RemoteUploaderDownloader,remote_file_name: str,local_file_name: Path,)),create_remote_up_down((# noqa: PLR0913 bucket_name: str,prefix: str,num_attempts: int,client_config: dict[str,Any],*,num_concurrent_uploads: int = 1,upload_staging_folder: str | None = None,use_procs: bool = True,)),__getattr__((self,name: str))[DUNDER],install((self)),_start_remote_workers((self)),__del__((self))[DUNDER],download_if_needed((self)),close((self)),_wait_for_staging_with_logging((self)),_resolve_remote_root((self))[HOT],_checkpoint_dir((self,step: int)),_raise_invalid_resume_format((self,cause: Exception | None = None)),_remote_key((self,relative_path: Path,remote_root: str | None = None)),save((self,curr_step: int,*,last_step: bool = False)),maybe_wait_for_staging((self)),_process_pending((self,flush: bool = False)),_is_directory_ready_for_upload((self,directory: Path)),_iter_checkpoint_files((self,directory: Path)),_find_local_latest_step((self)),setup_s3_checkpointing((checkpointer: CheckpointManager,job_config: MosaicJobConfig,*,install: bool = True,))] tokenizer.py→[build_mosaic_tokenizer((job_config: MosaicJobConfig,))[HOT]] train.py→[main(void)[ENTRY]→{s3_checkpoint::setup_s3_checkpointing,s3_checkpoint::setup_s3_checkpointing,ft_override::enable_desloc_only_ft,__init__::get_train_spec,__init__::get_train_spec}] validate.py→
[__init__((self,job_config: MosaicJobConfig,dp_world_size: int,dp_rank: int,tokenizer: BaseTokenizer,parallel_dims: ParallelDims,loss_fn: LossFunction,validation_context: Generator[None,None,None],maybe_enable_amp: Generator[None,None,None],metrics_processor: MetricsProcessor,pp_schedule: _PipelineSchedule | None = None,pp_has_first_stage: bool | None = None,pp_has_last_stage: bool | None = None,))[CTOR,DUNDER]→{dataloader::build_mosaic_validation_dataloader},build_mosaic_validator((job_config: MosaicJobConfig,dp_world_size: int,dp_rank: int,tokenizer: BaseTokenizer,parallel_dims: ParallelDims,loss_fn: LossFunction,validation_context: Generator[None,None,None],maybe_enable_amp: Generator[None,None,None],metrics_processor: MetricsProcessor,pp_schedule: _PipelineSchedule | None = None,pp_has_first_stage: bool | None = None,pp_has_last_stage: bool | None = None,))[HOT]] 

## DEPENDENCY_PATTERNS

### EDGE_PATTERNS
Contains: 123 edges
Call: 80 edges

### CROSS_CLUSTER_FLOW
DATA_MODELS→UTILITY_LAYER: 1
UTILITY_LAYER→DATA_MODELS: 7

